<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>ECE3140 / CS3420 Final Project Page by ece3140-sp2023</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Morse Code Security System</h1>
      <h2 class="project-tagline">Dakari Harris (dlh275) and Gabriel Seger (ges248)</h2>
      <a href="https://github.coecis.cornell.edu/ece3140-sp2023/base-page" class="btn">View base-page on GitHub</a>
    </section>
</body>

  <section class="main-content">
  <h3>Introduction</h3>
    <p>With security and privacy becoming a more prominent problem in our society, we wanted to create a different kind of lock system. 
	So, we created a morse code lock system using two switch buttons. The system consists of two major sections. First, the user will set a 
	4 digit password via morse code, using a button as input. Secondly, the user will be able to unlock the system with the button if the right password is passed. 
	The LEDs will show if the password is right or wrong, flashing red or green, and the LCD display will display what digit the user entered</p>
    <p>Our project was motivated by the fundamental usefulness and practicality of morse code combined with the importance of being able to have security
       features such as password locks. It is important to have a way to implement security even when you have very few methods of inputs. In certain scenarios,
       you will not be able to have a full number pad or more than just a few input devices. As a result we designed our locking mechanism to only use 
       two buttons on the board and be based on the timing of the button press to convert inputs into morse code which will allow you to enter a password to a lock.</p>

    
  <h3>System Overview</h3>  
    <p>The system works by first having the user use SW3 to enter a 4 digit passcode. The code is entered in morse code with a dot being signified by a short 
      button press and dash being signified by a longer button press. Waiting an interval of approximately 1 second or more signifies that a new number is being 
      entered. The converted morse code will be shown as a digit on the LCD. After the full passcode is recorded using SW3, it can be entered by pressing SW1 one 
      time. This will set the passcode and lock the “gate” while turning on a red light, indicating that the system is locked. From there, the user can enter 
      passcodes and if the passcode is correct, it will toggle the gate and the green LED will turn on, if not the gate will not change. </p>
    
     <h3>What We Learned</h3>  
    <p>We have learned how to use a Finite State Machine to keep track of the state of our lock. Additionally, we have learned how to initialize and set up 
      PIT interrupts to keep track of a global time variable. This project also allowed us to learn how to detect button presses using interrupts and be able
      to map these button presses to an LCD screen which we learned how to set up and use. </p>
    
    <h3>Video Example</h3>
    <iframe width="674" height="379" src="https://www.youtube.com/embed/-4pSgR1kPbE" title="ECEFinalVid" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
    
    <h3>System Diagram</h3>
	  <img src="https://raw.github.coecis.cornell.edu/ece3140-sp2023/dlh275-ges248/gh-pages/systemdiagram.PNG?token=GHSAT0AAAAAAAAANURGN3MGNTQIXG3VTNBMZDC4YNQ" alt="Figure 1: Hardware block diagram of system">

     <p> The components needed for the project were: a MKL46Z4 board, two switch buttons, a red LED, a green LED and a LCD display. The box diagram in figure 1, 
	  shows how the microcontroller and each of the components communicate with each other. Note that 
	  everything is centered around the MKL46Z4, and the switch buttons are inputs, while the LEDs and the LCD are outputs to the system.</p>
	  
    <h3>System Description</h3>
	  
    <h4><b>FSM:</b></h4>
	  <img src="https://raw.github.coecis.cornell.edu/ece3140-sp2023/dlh275-ges248/gh-pages/IMG_5136.jpg?token=GHSAT0AAAAAAAAANURGAXZUNAQGVQEJL3G2ZDC5OLA" alt="">
	 <p> Above is our Finite State Machine. This is the function that we loop through while waiting for interrupts to occur. There are 3 possible states that we could be in. 
	  The states are Reset, Locked and Unlocked. If we start in the reset state and SW1 has been pressed, we switch to the locked state. If we are in the locked state 
	  and the input code matches the code that has been set, we switch to the unlocked state and reset the input code. 
	  If we were in the unlocked state and the input code matches the code that had been set, we switch to the locked state and reset the input code.</p>
    
    <h4><b>current_time, local_time and button_presses:</b></h4>
 
     <p>These are global variables that are used to keep track of the time in between button presses and how many button presses have occurred. 
       The current time is incremented every millisecond by a PIT interrupt that we set up on channel 1 to call the PIT1_Service() function. 
       The local_time variable is set to the current_time every time SW3 is pressed down or up. This allows us to keep track of the amount of time in
       between button presses and how fast the button is pressed. Keeping track of the number of button presses is important because the button needs to 
       be both pressed down <b>and</b> released to count as one input which would be recorded as 2 button presses. As a result, we only wanted to record morse 
       code input when the number of button presses is even.s</p>
    <h4><b>PIT1_Service():</b></h4>
    <p>This function is called whenever either SW1 or SW3 is pressed, which triggers an interrupt. Inside this function, we check to see which button 
      was pressed and act accordingly. If SW3 was pressed, we record if it was a dot or a dash or the beginning of a new number. If it's the beginning
      of a new number, we record the old number in our code array and start the process of recording a morse code entry again. If SW1 was pressed, that
      means the user wants to enter the passcode and we call our FSM in order to enter whichever state needs to be entered based on our current state. </p>
    
    <h4><b>morse_to_int():</b></h4>
    <p>There are only 10 possible digits that could be entered using the button at a time (0-9). This function takes in an array of 5 dots and dahses (0 and 1's) and converts it to an integer.
     As a result, the easiest way to convert the array of morse inputs to an integer is to have 10 if statements that check each element of the 
      morse array and see if a dot or dash was entered. Depending on the order of dots and dashes, the if statements will return the correct integer.</p>
    
    <h4><b>LCD Library:</b></h4>
    <p>Making use of the LCD Library was not too difficult. We had to make sure we installed the correct drivers and imported the LCD.c and LCD.h files in 
      order to use the given functions. Once this was done, we were able to display the numbers we wanted to the LCD by simply calling init_lcd() and then 
      display_digit() for each digit that we wanted to display after it was translated from morse code.</p>
    
    <h3>Testing</h3>
    <p>This project had multiple steps of testing that needed to occur. The first step was making sure that the “code” array had the correct code in it
	    after entering the code in morse code. This was done by using the debugger to monitor the global variable “code” and make sure that the 
	    correct number was in the array after each number was entered in morse code. We tried every number and repeats of the same number in order to
	    try to account for edge cases and make sure we could convert every number from morse code to an integer correctly. We also tried cases where 
	    the input would be invalid.</p>
	<p>After we were confident that the “code” array had the correct value, we started displaying the integers of the code on the LCD screen. Once this
	    was added, we performed the same tests and made sure that each integer appeared on the screen correctly as it was entered in morse code. To 
	    make it more robust, we added some print statements that printed which button that was pressed and what the current input was. Finally, we 
	    tested the locking and unlocking functionalities. This was done by stepping through the debugger again while also making sure that the LEDs 
	    output were correct.</p>

 
<h3>Additional Resources Used</h3>
	<p>We read input from the SW1 button using the switch_demo.c code that was provided to us. We also used the LCD Library that was provided to us in order to display the 
	passcode that was entered.  Additionally, we used the LED utility file that was provided earlier in the term. Finally, we used the KL46 Sub-Family Reference Manual
	to correctly configure the timer and  our inputs. </p> 
	  
<h3>Work Distribution</h3>
	 <p>We mostly collaborated via text and Zoom as we couldn't find a common time to work in person for the majority of the project due to other 
	 obligations. We were still able to collaborate and communicate effectively as we had daily contact regarding updates. Fortunately, we 
	 managed to get together in the last two days to produce the video and debug it together. We began the project via Zoom, where we both 
	 contributed with ideas and roughly planned the project. We then continued to do a great deal of coding during our zoom meetings, which 
	 began last week and continued through the weekend. Dakari had the board, but we reviewed any code we designed  together online. Both took 
	 an active role in writing test cases and working with the web page. Other than Zoom and text, we used Google Drive and Github to share code 
	 with each other. 
</p>
    
  </section>
</html>
